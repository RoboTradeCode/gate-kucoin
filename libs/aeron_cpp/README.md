# Примеры использования протокола Aeron на C++

Aeron — это протокол для передачи сообщений, главная цель которого — достичь максимальной пропускной способности с
наименьшей и наиболее предсказуемой задержкой. Библиотека имеет несколько реализаций, включая реализацию на С/С++.

Aeron может передавать сообщение с помощью протокола UDP (в сети Интернет) и через общую память (IPC - Inter Process
Communication). Оба способа поддерживают режим Multicast, то есть отправку сообщения сразу нескольким получателям.

В репозитории представлены базовые примеры реализации отправки и получения сообщений, используя протокол Aeron:

1. [`BasicPublisher`](examples/BasicPublisher.cpp)
2. [`BasicSubscriber`](examples/BasicSubscriber.cpp)

Сборка осуществляется с использованием утилиты [CMake](https://ru.wikipedia.org/wiki/CMake). Для её упрощения вы можете
воспользоваться скриптом [build.sh](build.sh). После его исполнения собранный код будет находиться в директории
build/Debug:

```shell
./build.sh
```

> Перед запуском любых примеров убедитесь, что на вашем компьютере и удалённом сервере запущен медиа-драйвер

## BasicPublisher

В примере представлена реализация отправки сообщений через общую память:

```c++
Publisher publisher("aeron:ipc");
publisher.offer("Hello, World!");
```

### Канал

При создании объекта `Publisher` (так же и для `Subscriber`), в него требуется передать канал.

**Канал** связывает отправителя данных с получателем. Он задаётся строкой, которая собирается
по [определённым правилам](https://github.com/real-logic/aeron/wiki/Channel-Configuration). В начале строки находится
медиа-значение — оно определяет протокол, который Aeron будет использовать для отправки сообщений. После протокола идут
параметры в формате `ключ=значение`.

В примерах данные передаются по IPC — для этого используется
соответствующее [медиа-значение `aeron:ipc`](https://github.com/real-logic/aeron/wiki/Channel-Configuration#ipc-media---inter-process-communication).

#### Multicast (Отправка нескольким получателям)

Если требуется передавать данные нескольким подписчикам одновременно (в режиме Multicast), нужно указать параметры
канала `control` и `control-mode`.

Параметр `control-mode` задаёт режим управления подписчиками. Существует два режима: ручной (`manual`) и
динамический (`dynamic`). В динамическом режиме добавление новых подписчиков происходит автоматически, а не из
программного кода.

Параметр `control` задаёт IP-адрес (локальный), на который подписчики будут посылать запросы на подключение. Это должен
быть IP-адрес и порт доступного локального интерфейса:

```c++
Publisher publisher("aeron:udp?control=172.31.14.205:40456|control-mode=dynamic");
```

> Вы можете найти локальный IP-адрес, исполнив команду `ip addr show`

### Идентификатор потока

В Aeron вы можете использовать один и тот же канал для передачи разных потоков данных. Чтобы отличить их, используется
идентификатор потока (Stream ID). Вы можете передать его вторым аргументом в конструктор класса:

```c++
Publisher publisher("aeron:udp?endpoint=54.248.171.18:20121", 1001);
```

> `1001` является значением по умолчанию. Такое же значение используют [примеры в репозитории Aeron](https://github.com/real-logic/aeron/blob/master/aeron-samples).

### Размер буфера

Перед тем как передать сообщение, его нужно записать в заранее инициализированный буфер.

Размер буфера напрямую влияет на размер отправляемых сообщений, поэтому пользователю дана возможность указать его в
байтах третьим параметром:

```c++
Publisher publisher("aeron:udp?endpoint=54.248.171.18:20121", 1001, 1400);
```

На размер не накладывается ограничений. Но важно понимать, что если отправляемые сообщения не будут помещаться
в [MTU](https://ru.wikipedia.org/wiki/Maximum_transmission_unit) (максимальная единица передачи в сети), то они будут
фрагментированы независимо от размера буфера.

Фрагментация сообщений в разы увеличивает время передачи. Среднее MTU составляет 1400 байт. Для максимальной
производительности размер одного сообщения не должен превышать этого значения.

> По умолчанию размер буфера составляет именно 1400 байт

### Максимальное количество фрагментов

Если Ваши сообщения всё же превышают MTU, то они будут фрагментированы. Из-за этого на принимающей стороне потребуется
дополнительно собрать сообщение из частей. Это происходит автоматически, но требуется указать максимально возможное
количество фрагментов. По умолчанию оно составляет 10 единиц, но вы можете изменить его с помощью четвертого параметра:

```c++
Publisher publisher("aeron:udp?endpoint=54.248.171.18:20121", 1001, 1400, 10);
```

### Отправка сообщения

Для отправки используется метод `offer`. Он принимает сообщение в виде строки:

```c++
publisher.offer("Hello World!");
```

## BasicSubscriber

В примере представлена реализация приёма сообщений через общую память:

```c++
std::shared_ptr<Subscriber> subscriber = std::make_shared<Subscriber>(handler, "aeron:ipc");
aeron::SleepingIdleStrategy idle_strategy(std::chrono::milliseconds(1));

while (running)
    idle_strategy.idle(subscriber->poll());
```

### Функция обратного вызова

Для обработки сообщений необходимо передавать в конструктор класса функцию со следующей сигнатурой:

```c++
std::function<void (std::string_view)>
```

### Канал и идентификатор потока

Формирование канала аналогично формированию канала для `Publisher`. Также можно указать и идентификатор потока:

```c++
std::make_shared<Subscriber>(handler, "aeron:udp?endpoint=172.31.14.205:20121", 1001);
```

#### Multicast

При формировании Multicast-канала для `Publisher` задаётся параметр `control`. Этот же параметр должны указать
подписчики, чтобы присоединиться к рассылке (в дополнение к `endpoint`):

```c++
std::make_shared<Subscriber>(handler, "aeron:udp?endpoint=172.31.14.205:40457|control=54.248.171.18:40456");
```

> Когда мы формировали канал для `BasicPublisher`, мы передавали в параметр `control` _локальный_ адрес. Сейчас мы
> указываем _внешний_ (тот, что доступен из интернета)


Если рассылка происходит от нескольких `Publisher`'ов, то нужно воспользоваться ручным режимом добавления:

```c++
std::shared_ptr<Subscriber> subscriber = std::make_shared<Subscriber>(handler, "aeron:udp?control-mode=manual");
subscriber->add_destination("aeron:udp?endpoint=172.31.14.205:40457|control=54.248.171.18:40456");
```

> Отменить подписку на канал можно с помощью метода `remove_destination`

Обобщённую схему настройки для режима Multicast можно представить следующим образом:

![Обобщённая схема Multicast](https://user-images.githubusercontent.com/44947427/153732778-d3ba28d3-07bd-465b-b561-0bd35b0d8cbc.png)

### Получение сообщений

Проверить наличие новых сообщений можно, вызвав метод `poll`:

```c++
int fragments_read = subscriber->poll();
```

Если новые сообщения имеются, они будут получены и переданы в функцию обратного вызова (задаётся в конструкторе класса).

### Стратегия ожидания

Для того чтобы избежать чрезмерной нагрузки на процессор, используется стратегия ожидания `SleepingIdleStrategy`.

После каждой проверки на наличие сообщений в функцию `idle_strategy` передаётся количество принятых фрагментов. Если
хоть что-то было принято, функция передаёт управление обратно, позволяя сразу же принимать новые сообщения. Если ничего
не было принято, функция делает паузу (1 мс):

```c++
aeron::SleepingIdleStrategy idle_strategy(std::chrono::milliseconds(1));

while (running)
    idle_strategy.idle(subscriber->poll());
```

> Для максимальной производительности можно вообще не использовать стратегию ожидания
